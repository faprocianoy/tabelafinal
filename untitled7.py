# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RqRjmSeGDeWat37gCOURABwIics8XTNC
"""

pip install yfinance pandas openpyxl

import yfinance as yf
import pandas as pd
import time

# Lista de tickers
tickers = [
   "AMBP3.SA", "CLSA3.SA", "LOGN3.SA", "RAIL3.SA", "PTBL3.SA", "HAPV3.SA", "NGRD3.SA",
    "AURA33.SA", "AESB3.SA", "ANIM3.SA", "RCSL3.SA", "ZAMP3.SA", "CSNA3.SA", "SIMH3.SA",
    "VVEO3.SA", "CVCB3.SA", "CASH3.SA", "LIGT3.SA", "QUAL3.SA", "MRVE3.SA", "GFSA3.SA",
    "HBSA3.SA", "CBAV3.SA", "COGN3.SA", "MOVI3.SA", "MATD3.SA", "RCSL4.SA", "DASA3.SA",
    "ALPA4.SA", "AERI3.SA", "MLAS3.SA", "NTCO3.SA", "BRKM5.SA", "TRAD3.SA", "AZEV4.SA",
    "PCAR3.SA", "AZUL4.SA", "GOLL4.SA", "BHIA3.SA", "SEQL3.SA", "IFCM3.SA", "OIBR3.SA",
    "AMER3.SA", "VBBR3.SA", "SYNE3.SA", "POSI3.SA", "ETER3.SA", "BRAP3.SA", "BRAP4.SA",
    "HBOR3.SA", "HBRE3.SA", "BBAS3.SA", "ECOR3.SA", "PINE4.SA", "CMIG4.SA", "MDNE3.SA",
    "JHSF3.SA", "BRSR6.SA", "ABCB4.SA", "SBFG3.SA", "LAVV3.SA", "BMGB4.SA",
    "CYRE3.SA", "CMIG3.SA", "VALE3.SA", "WIZC3.SA", "CAML3.SA", "VLID3.SA", "BMEB4.SA",
    "LOGG3.SA", "PETR4.SA", "SAPR3.SA", "POMO3.SA", "SAPR11.SA", "SAPR4.SA", "COCE5.SA",
    "NEOE3.SA", "SOJA3.SA", "LEVE3.SA", "PETR3.SA", "TRIS3.SA", "SBSP3.SA", "CSMG3.SA",
    "CPFE3.SA", "PLPL3.SA", "ROMI3.SA", "KEPL3.SA", "GOAU4.SA", "ITSA4.SA", "CSED3.SA",
    "ENGI11.SA", "PRIO3.SA", "GRND3.SA", "FIQE3.SA", "ITSA3.SA", "SMTO3.SA", "EZTC3.SA",
    "MILS3.SA", "SHUL4.SA", "CMIN3.SA", "JSLG3.SA", "EGIE3.SA", "BBDC3.SA", "UGPA3.SA",
    "ITUB3.SA", "HYPE3.SA", "SANB3.SA", "MTRE3.SA", "BRBI11.SA", "CSAN3.SA", "RECV3.SA",
    "AGRO3.SA", "PFRM3.SA", "USIM3.SA", "VULC3.SA", "INTB3.SA", "POMO4.SA", "TAEE11.SA",
    "USIM5.SA", "SANB11.SA", "VAMO3.SA", "TAEE4.SA", "CPLE3.SA", "BBDC4.SA", "ELET3.SA",
    "BBSE3.SA", "MELK3.SA", "GGBR3.SA", "CEAB3.SA", "ITUB4.SA", "SANB4.SA", "ALUP11.SA",
    "GGBR4.SA", "TTEN3.SA", "TGMA3.SA", "MDIA3.SA", "ELET6.SA", "CPLE6.SA", "LJQQ3.SA",
    "DIRR3.SA", "CURY3.SA", "PSSA3.SA", "TUPY3.SA", "RAPT4.SA", "EVEN3.SA", "MYPK3.SA",
    "BPAC11.SA", "FESA4.SA", "MULT3.SA", "ARML3.SA", "VIVA3.SA", "BMOB3.SA", "ODPV3.SA",
    "OPCT3.SA", "PGMN3.SA", "YDUQ3.SA", "VITT3.SA", "FLRY3.SA", "BPAN4.SA", "JBSS3.SA",
    "GMAT3.SA", "SMFT3.SA", "LREN3.SA", "IRBR3.SA", "B3SA3.SA", "TFCO4.SA", "CXSE3.SA",
    "JALL3.SA", "ASAI3.SA", "BLAU3.SA", "AZZA3.SA", "UNIP6.SA", "RANI3.SA",
    "CCRO3.SA", "KLBN4.SA", "PNVL3.SA", "AURE3.SA", "KLBN11.SA", "KLBN3.SA",
    "TASA4.SA", "BRFS3.SA", "STBP3.SA", "IGTI11.SA", "PORT3.SA", "GUAR3.SA", "VIVT3.SA",
    "DESK3.SA", "GGPS3.SA", "ABEV3.SA", "EMBR3.SA", "EQTL3.SA", "RDOR3.SA", "DXCO3.SA",
    "MGLU3.SA", "FRAS3.SA", "SRNA3.SA", "SUZB3.SA", "SLCE3.SA",
    "SEER3.SA", "ORVR3.SA", "RENT3.SA", "TIMS3.SA", "TEND3.SA", "TOTS3.SA", "ONCO3.SA",
    "ENEV3.SA", "RAIZ4.SA", "ELMD3.SA", "RADL3.SA", "WEGE3.SA", "MRFG3.SA", "LWSA3.SA",
    "PETZ3.SA", "PRNR3.SA", "CRFB3.SA", "BEEF3.SA",
]

# Função para calcular os dados financeiros
def get_financial_data(ticker):
    stock = yf.Ticker(ticker)
    info = stock.info
    financial_data = {
        'Share Price': None,
        'EPS': None,
        'P/E': None,
        'ROE': info.get('returnOnEquity', None),
        'Debt': info.get('totalDebt', None),
        'Market Cap': info.get('marketCap', None),
        'Debt to Market Cap': None,
        'Nov Return': None,
        'Return in 2023': None,
        '2Y Monthly Return Std Dev': None,
        '2Y Cumulative Return': None
    }

    try:
        # Preço da ação baseado no fechamento mais recente
        hist = stock.history(period="5d")  # Últimos 5 dias para garantir dados recentes
        if not hist.empty:
            financial_data['Share Price'] = hist['Close'].iloc[-1]

        # EPS (Earnings Per Share)
        financial_data['EPS'] = info.get('trailingEps', None)

        # Cálculo do P/E manual
        if financial_data['Share Price'] is not None and financial_data['EPS'] is not None:
            financial_data['P/E'] = financial_data['Share Price'] / financial_data['EPS']

        # Retorno em Novembro
        hist_nov = stock.history(period="1mo")
        if not hist_nov.empty:
            financial_data['Nov Return'] = hist_nov['Close'].pct_change().iloc[-1]

        # Retorno acumulado em 2023
        hist_2023 = stock.history(period="1y", start="2023-01-01", end="2023-12-31")
        if not hist_2023.empty:
            financial_data['Return in 2023'] = (hist_2023['Close'].pct_change() + 1).prod() - 1

        # Desvio padrão do retorno mensal nos últimos 2 anos
        hist_2y = stock.history(period="2y")
        if not hist_2y.empty:
            monthly_returns = hist_2y['Close'].pct_change().resample('M').mean()
            financial_data['2Y Monthly Return Std Dev'] = monthly_returns.std()

            # Retorno acumulado dos últimos 2 anos
            financial_data['2Y Cumulative Return'] = (monthly_returns + 1).prod() - 1

    except Exception as e:
        print(f"Erro ao obter dados financeiros para {ticker}: {e}")

    # Formatando a dívida e o market cap
    if financial_data['Debt'] is not None:
        if financial_data['Debt'] >= 1e9:
            financial_data['Debt'] = f"{financial_data['Debt'] / 1e9:.2f}B"
        elif financial_data['Debt'] >= 1e6:
            financial_data['Debt'] = f"{financial_data['Debt'] / 1e6:.2f}M"
        elif financial_data['Debt'] >= 1e3:  # Aqui é onde o "k" é adicionado
            financial_data['Debt'] = f"{financial_data['Debt'] / 1e3:.1f}K"

    if financial_data['Market Cap'] is not None:
        if financial_data['Market Cap'] >= 1e9:
            financial_data['Market Cap'] = f"{financial_data['Market Cap'] / 1e9:.2f}B"
        elif financial_data['Market Cap'] >= 1e6:
            financial_data['Market Cap'] = f"{financial_data['Market Cap'] / 1e6:.2f}M"
        elif financial_data['Market Cap'] >= 1e3:  # Aqui também o "k" será adicionado
            financial_data['Market Cap'] = f"{financial_data['Market Cap'] / 1e3:.1f}K"

    # Dívida sobre Market Cap
    if financial_data['Debt'] is not None and financial_data['Market Cap'] is not None:
        try:
            debt_market_cap_ratio = float(financial_data['Debt'].replace('B', '').replace('M', '').replace('K', '')) / float(financial_data['Market Cap'].replace('B', '').replace('M', '').replace('K', ''))
            financial_data['Debt to Market Cap'] = f"{debt_market_cap_ratio:.2f}x"
        except ValueError:
            financial_data['Debt to Market Cap'] = None

    return financial_data

# Função com reintento
def get_financial_data_with_retry(ticker, retries=3, delay=5):
    for attempt in range(retries):
        try:
            return get_financial_data(ticker)
        except Exception as e:
            print(f"Erro ao obter dados para {ticker}: {e}. Tentando novamente ({attempt + 1}/{retries})...")
            time.sleep(delay)
    print(f"Falha ao obter dados para {ticker} após {retries} tentativas.")
    return None

# Coletando os dados financeiros com reintento
data = []
valid_tickers = []

for ticker in tickers:
    print(f"Processando {ticker}...")
    financial_data = get_financial_data_with_retry(ticker)
    if financial_data:
        data.append(financial_data)
        valid_tickers.append(ticker)
    time.sleep(1)  # Pausa de 1 segundo entre as requisições para evitar limite de requisições

# Convertendo para DataFrame com tickers válidos
df = pd.DataFrame(data, index=valid_tickers)

# Formatando os dados conforme especificado
df['ROE'] = (df['ROE'] * 100).round(1)  # ROE em porcentagem com 1 casa decimal
df['P/E'] = df['P/E'].round(1)  # P/E com 1 casa decimal
df['Share Price'] = df['Share Price'].round(2)  # Preço da ação com 2 casas decimais

# Adicionando "%" para as colunas de retorno
df['Nov Return'] = (df['Nov Return'] * 100).round(2).astype(str) + '%'
df['Return in 2023'] = (df['Return in 2023'] * 100).round(2).astype(str) + '%'
df['2Y Monthly Return Std Dev'] = (df['2Y Monthly Return Std Dev'] * 100).round(2).astype(str) + '%'
df['2Y Cumulative Return'] = (df['2Y Cumulative Return'] * 100).round(2).astype(str) + '%'

# Ordenando por ROE em ordem decrescente
df = df.sort_values(by='ROE', ascending=False)

# Criando e salvando o arquivo Excel no diretório atual
output_filename = "financial_data.xlsx"
df.to_excel(output_filename)

# Exibindo o DataFrame completo e caminho para o download
print(df)
print(f"Arquivo Excel gerado: {output_filename}")